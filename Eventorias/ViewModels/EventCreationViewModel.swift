//
//  EventCreationViewModel.swift
//  Eventorias
//
//  Created by TLiLi Hamdi on 05/06/2025.
//

import SwiftUI
import Combine
import FirebaseStorage
import FirebaseFirestore
import FirebaseAuth
import Photos
import AVFoundation
import UIKit

/// ViewModel responsable de la gestion de la cr√©ation d'√©v√©nements
@MainActor
final class EventCreationViewModel: ObservableObject {
    // MARK: - Published Properties
    
    // Form values
    @Published var eventTitle: String = "New event"
    @Published var eventDescription: String = "Tap here to enter your description"
    @Published var eventDate: Date = Date()
    @Published var eventAddress: String = ""
    @Published var eventImage: UIImage?
    
    // UI state
    @Published var showingAlert = false
    @Published var alertTitle = ""
    @Published var alertMessage = ""
    @Published var imageUploadState: ImageUploadState = .idle
    @Published var eventCreationSuccess = false
    @Published var errorMessage = ""
    @Published var imageURL: String = ""
    @Published var cameraPermissionGranted = false
    @Published var photoLibraryPermissionGranted = false
    
    // MARK: - Dependencies
    
    private let eventViewModel: EventViewModel
    
    // Firebase Storage
    private let storage = Storage.storage()
    private let db = Firestore.firestore()
    
    // MARK: - Initialization
    
    init(eventViewModel: EventViewModel) {
        self.eventViewModel = eventViewModel
        
        // Les v√©rifications d'autorisations seront effectu√©es √† la demande
        // pour √©viter de provoquer des dialogues syst√®me lors de l'initialisation
    }
    
    // MARK: - Image Upload State
    
    enum ImageUploadState: Equatable {
        case idle
        case uploading(Double)
        case success
        case failure
        
        static func ==(lhs: ImageUploadState, rhs: ImageUploadState) -> Bool {
            switch (lhs, rhs) {
            case (.idle, .idle), (.success, .success), (.failure, .failure):
                return true
            case (.uploading(let lhsProgress), .uploading(let rhsProgress)):
                return lhsProgress == rhsProgress
            default:
                return false
            }
        }
    }
    
    // MARK: - Methods
    
    /// Cr√©e un nouvel √©v√©nement avec les valeurs actuelles
    /// - Returns: Un bool√©en indiquant si la cr√©ation a r√©ussi
    @MainActor
    func createEvent() async -> Bool {
        print("‚ö†Ô∏è DEBUG: D√©but createEvent - Thread: \(Thread.current.isMainThread ? "Main" : "Background")")
        // Validation des champs requis
        if eventTitle.isEmpty {
            errorMessage = "Veuillez saisir un titre pour l'√©v√©nement"
            return false
        }
        
        if eventAddress.isEmpty {
            errorMessage = "Veuillez saisir une adresse pour l'√©v√©nement"
            return false
        }
        
        // R√©initialisation des erreurs
        errorMessage = ""
        imageUploadState = .idle
        
        // Upload de l'image si elle existe
        print("‚ö†Ô∏è DEBUG: Image pr√©sente pour upload: \(eventImage != nil)")
        if let image = eventImage {
            do {
                // Tenter d'uploader l'image d'abord
                try await uploadImage(image)
            } catch {
                errorMessage = "Erreur lors de l'upload de l'image: \(error.localizedDescription)"
                imageUploadState = .failure
                return false
            }
        }
        
        // Cr√©er le nouvel √©v√©nement
        do {
            // Cr√©er un document dans Firestore
            let eventRef = db.collection("events").document()
            
            // Obtenir l'utilisateur connect√© pour l'organisateur (si disponible)
            let auth = Auth.auth()
            let organizer = auth.currentUser?.displayName ?? "Utilisateur anonyme"
            let organizerEmail = auth.currentUser?.email
            
            // Cr√©er le mod√®le d'√©v√©nement conforme √† notre mod√®le Event
            let newEvent = Event(
                id: eventRef.documentID,
                title: eventTitle,
                description: eventDescription,
                date: eventDate,
                location: eventAddress,  // utilise eventAddress comme location
                organizer: organizer,     // nom de l'utilisateur connect√©
                organizerImageURL: nil,   // pas d'image de l'organisateur pour l'instant
                imageURL: imageURL,       // URL de l'image upload√©e sur Firebase Storage
                category: "G√©n√©ral",      // cat√©gorie par d√©faut
                tags: ["Nouvel √©v√©nement"],  // tag par d√©faut
                createdAt: Date()         // date de cr√©ation actuelle
            )
            
            // Enregistrer dans Firestore
            try await eventRef.setData(from: newEvent)
            
            // Mettre √† jour l'√©tat
            eventCreationSuccess = true
            return true
        } catch {
            errorMessage = "Erreur lors de la cr√©ation de l'√©v√©nement: \(error.localizedDescription)"
            return false
        }
    }
    
    /// R√©initialise les valeurs du formulaire
    func resetForm() {
        eventTitle = "New event"
        eventDescription = "Tap here to enter your description"
        eventDate = Date()
        eventAddress = ""
        eventImage = nil
        imageUploadState = .idle
        eventCreationSuccess = false
        errorMessage = ""
    }
    
    /// Upload une image sur Firebase Storage avec suivi de progression
    /// - Parameter image: UIImage √† uploader
    @MainActor
    func uploadImage(_ image: UIImage) async throws {
        print("‚ö†Ô∏è DEBUG: D√©but de la m√©thode uploadImage")
        
        // V√©rifier que l'image est valide
        guard let imageData = image.jpegData(compressionQuality: 0.7) else {
            print("‚ùå DEBUG: Impossible de convertir l'image en donn√©es JPEG")
            throw NSError(domain: "EventCreationViewModel", code: 1001, userInfo: [NSLocalizedDescriptionKey: "Impossible de convertir l'image en donn√©es JPEG"])
        }
        
        // V√©rifier que les donn√©es ne sont pas vides
        guard !imageData.isEmpty else {
            print("‚ùå DEBUG: Donn√©es d'image vides")
            throw NSError(domain: "EventCreationViewModel", code: 1002, userInfo: [NSLocalizedDescriptionKey: "Donn√©es d'image vides"])
        }
        
        // Mise √† jour de l'√©tat initial
        imageUploadState = .uploading(0.0)
        
        // Utiliser un UUID sans tirets pour √©viter des probl√®mes potentiels de chemin
        let imageName = UUID().uuidString.replacingOccurrences(of: "-", with: "") + ".jpg"
        let imagePath = "event_images/"
        let fullPath = imagePath + imageName
        
        print("üìÅ DEBUG: Chemin complet du fichier: \(fullPath)")
        
        // Cr√©er la r√©f√©rence Storage
        let storageRef = storage.reference().child(fullPath)
        
        // Cr√©er les m√©tadonn√©es pour l'image
        let metadata = StorageMetadata()
        metadata.contentType = "image/jpeg"
        
        do {
            // Mettre en place un Task pour suivre la progression
            let progressTask = Task {
                // Cr√©er un uploadTask pour suivre la progression
                let uploadTask = storageRef.putData(imageData, metadata: metadata)
                
                // Observer la progression et mettre √† jour l'UI
                uploadTask.observe(.progress) { [weak self] snapshot in
                    guard let self = self, let progress = snapshot.progress else { return }
                    let percentComplete = Double(progress.completedUnitCount) / Double(progress.totalUnitCount)
                    
                    Task { @MainActor in
                        self.imageUploadState = .uploading(percentComplete)
                        print("üì§ Upload: \(Int(percentComplete * 100))%")
                    }
                }
            }
            
            print("‚ö†Ô∏è DEBUG: D√©marrage de l'upload avec putDataAsync")
            
            // IMPORTANT: Utiliser putDataAsync qui attend automatiquement la fin de l'upload
            // avant de continuer l'ex√©cution du code
            try await storageRef.putDataAsync(imageData, metadata: metadata)
            
            // L'upload est maintenant termin√©
            print("‚úÖ DEBUG: Upload compl√®tement termin√© avec putDataAsync")
            print("üíæ DEBUG: Fichier upload√© √†: \(storageRef.fullPath)")
            
            // Annuler le task de progression car l'upload est termin√©
            progressTask.cancel()
            
            // Tenter de r√©cup√©rer l'URL de t√©l√©chargement avec une logique de nouvelle tentative
            let downloadURL = try await getDownloadURLWithRetries(for: storageRef, retries: 3, delay: .seconds(1))

            print("‚úÖ DEBUG: URL obtenue avec succ√®s: \(downloadURL.absoluteString)")

            // Mise √† jour du mod√®le avec l'URL
            self.imageURL = downloadURL.absoluteString
            self.imageUploadState = .success
            print("üèÅ Upload r√©ussi et URL r√©cup√©r√©e: \(downloadURL.absoluteString)")
            
            // Mise √† jour du mod√®le avec l'URL
            self.imageURL = downloadURL.absoluteString
            self.imageUploadState = .success
            print("üèÅ Upload r√©ussi et URL r√©cup√©r√©e: \(downloadURL.absoluteString)")
            
            return
        } catch {
            print("‚ùå DEBUG: Erreur lors de l'upload: \(error.localizedDescription)")
            imageUploadState = .failure
            throw error
        }
    }
    /// Tente de r√©cup√©rer l'URL de t√©l√©chargement avec plusieurs tentatives en cas d'√©chec.
    private func getDownloadURLWithRetries(for ref: StorageReference, retries: Int, delay: Duration) async throws -> URL {
        var lastError: Error?
        for attempt in 0..<retries {
            do {
                print("üìç DEBUG: Tentative \(attempt + 1) de r√©cup√©ration de l'URL...")
                return try await ref.downloadURL()
            } catch let error as NSError where error.code == StorageErrorCode.objectNotFound.rawValue {
                print("‚ö†Ô∏è DEBUG: Objet non trouv√©, nouvelle tentative dans \(delay.description)...")
                lastError = error
                try await Task.sleep(for: delay)
            } catch {
                // Pour toute autre erreur, √©chouer imm√©diatement
                throw error
            }
        }
        // Si toutes les tentatives √©chouent, lancer la derni√®re erreur connue
        throw lastError ?? NSError(domain: "EventCreationViewModel", code: 1003, userInfo: [NSLocalizedDescriptionKey: "Impossible de r√©cup√©rer l'URL de t√©l√©chargement apr√®s \(retries) tentatives."])
    }

    // MARK: - Gestion des permissions
    
    /// Ouvre les r√©glages de l'application pour permettre √† l'utilisateur de modifier les autorisations
    func openAppSettings() {
        if let url = URL(string: UIApplication.openSettingsURLString) {
            if UIApplication.shared.canOpenURL(url) {
                UIApplication.shared.open(url)
            }
        }
    }
    
    /// V√©rifie et demande l'autorisation d'acc√®s √† la galerie de photos
    func checkPhotoLibraryPermission() {
        let status = PHPhotoLibrary.authorizationStatus()
        handlePhotoLibraryAuthorizationStatus(status)
    }
    
    /// G√®re l'√©tat d'autorisation de la galerie de photos
    private func handlePhotoLibraryAuthorizationStatus(_ status: PHAuthorizationStatus) {
        print("‚ö†Ô∏è DEBUG: √âtat permission phototh√®que: \(status)")
        switch status {
        case .authorized, .limited:
            photoLibraryPermissionGranted = true
        case .notDetermined:
            PHPhotoLibrary.requestAuthorization { [weak self] newStatus in
                DispatchQueue.main.async {
                    switch newStatus {
                    case .authorized, .limited:
                        self?.photoLibraryPermissionGranted = true
                    case .denied, .restricted:
                        self?.photoLibraryPermissionGranted = false
                        self?.errorMessage = "L'acc√®s √† vos photos est requis pour s√©lectionner une image. Vous pouvez modifier ce param√®tre dans les R√©glages."
                    case .notDetermined:
                        self?.photoLibraryPermissionGranted = false
                    @unknown default:
                        self?.photoLibraryPermissionGranted = false
                    }
                }
            }
        case .denied, .restricted:
            photoLibraryPermissionGranted = false
            errorMessage = "L'acc√®s √† vos photos est requis pour s√©lectionner une image. Vous pouvez modifier ce param√®tre dans les R√©glages."
        @unknown default:
            photoLibraryPermissionGranted = false
        }
    }
    
    /// V√©rifie et demande l'autorisation d'acc√®s √† la cam√©ra
    func checkCameraPermission() {
        let status = AVCaptureDevice.authorizationStatus(for: .video)
        handleCameraAuthorizationStatus(status)
    }
    
    /// G√®re l'√©tat d'autorisation de la cam√©ra
    private func handleCameraAuthorizationStatus(_ status: AVAuthorizationStatus) {
        print("‚ö†Ô∏è DEBUG: √âtat permission cam√©ra: \(status)")
        switch status {
        case .authorized:
            cameraPermissionGranted = true
        case .notDetermined:
            AVCaptureDevice.requestAccess(for: .video) { [weak self] granted in
                Task { @MainActor in
                    self?.cameraPermissionGranted = granted
                    if !granted {
                        self?.errorMessage = "L'acc√®s √† la cam√©ra est requis pour prendre une photo. Vous pouvez modifier ce param√®tre dans les R√©glages."
                    }
                }
            }
        case .denied, .restricted:
            cameraPermissionGranted = false
            errorMessage = "L'acc√®s √† la cam√©ra est requis pour prendre une photo. Vous pouvez modifier ce param√®tre dans les R√©glages."
        @unknown default:
            cameraPermissionGranted = false
        }
    }
}
